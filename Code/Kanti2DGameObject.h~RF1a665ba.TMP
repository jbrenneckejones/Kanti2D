#ifndef KANTI2D_GAMEOBJECT

struct ContactPoint
{
	// Normal of the contact point.
	Vector2 Normal;

	// The other collider in contact at the point.
	class Collider* OtherCollider;

	// The point of contact.
	Vector2 Point;

	// The first collider in contact at the point.
	class Collider* ThisCollider;
};

struct Collision
{
	// The collider attached to the object receiving the collision message.
	class Collider* Caller;

	// Surface normal at the contact point.
	Vector2 Normal;

	// The incoming collider involved in the collision at this contact point.
	class Collider* Collider;

	// The specific points of contact with the incoming Collider2D.
	std::vector<ContactPoint> Contacts;

	// The relative linear velocity of the two colliding objects.
	Vector2 RelativeVelocity;

	Collision(class Collider& CalledOnCollider, class Collider& IncomingCollider);


};

class Entity
{
public:

	// Variables

	string Name;
	UniqueID InstanceID;

	uint32 Layer;

public:

	// Functions

	Entity()
	{
		Name = "Object";
		InstanceID = GetUUID();
		Layer = 0;
	}

	Entity(string EntityName)
	{
		InstanceID = GetUUID();
		Name = EntityName;
		Layer = 0;
	}

	virtual ~Entity() {};

	bool32 operator ==(const Entity& Comparer)
	{
		return InstanceID == Comparer.InstanceID;
	}

	bool32 operator ==(Entity& Comparer)
	{
		return InstanceID == Comparer.InstanceID;
	}

	bool32 operator ==(Entity Comparer)
	{
		return InstanceID == Comparer.InstanceID;
	}

	bool32 operator ==(Entity* Comparer)
	{
		if (!Comparer)
		{
			return false;
		}

		return InstanceID == Comparer->InstanceID;
	}
};

class GameComponent : public Entity
{
public:

	// Variables

	class GameEntity* EntityAttachedTo;

public:

	// Functions

	inline GameComponent()
	{
	};

	virtual ~GameComponent() {};

	inline GameComponent(string ComponentName, GameEntity* AttachedTo)
	{
		Name = ComponentName;
		EntityAttachedTo = AttachedTo;
	}
};

class Transform : public GameComponent
{
public:

	// Variables

	Vector2 Position;
	Vector2 Scale;
	Vector2 Rotation;

	GameEntity* Parent;

public:

	// Functions

	inline Transform()
	{
		Position = Vector2::Zero;
		Scale = Vector2::Zero;
		Rotation = Vector2::Zero;
	}
};

class GameEntity : public Entity
{
public:

	// Variables

	bool32 IsActive;

	std::vector<class GameComponent*> Components;

	Transform EntTransform;

	const GameEntity* GameObject = this;

public:

	// Functions

	inline GameEntity()
	{
	}

	inline GameEntity(string ObjectName) : Entity(ObjectName)
	{
		Name = ObjectName;
	}

	virtual ~GameEntity() {};

	template<class GameComponent>
	GameComponent* AddComponent();

	template<class GameComponent>
	GameComponent* AddComponent(GameComponent* ComponentPrefab);

	template<class GameComponent>
	GameComponent* GetComponent();
};

class Behaviour : public GameComponent
{
public:

	// Variables

	bool32 IsActive;

public:

	// Functions

	inline Behaviour()
	{
		IsActive = true;
	}

	virtual ~Behaviour() {};
};

class GameBehaviour : public Behaviour
{
public:

	// Variables

public:

	// Functions

	inline GameBehaviour()
	{
		AddHandlers();
	}

	inline void AddHandlers();

	virtual ~GameBehaviour() {};

	virtual void OnCollisionStart(const Collision& CollideInfo) {};
	virtual void OnCollisionStay(const Collision& CollideInfo) {};
	virtual void OnCollisionEnd(const Collision& CollideInfo) {};

	virtual void OnTriggerEnter(const Collider& Collided) {};
	virtual void OnTriggerStay(const Collider& Collided) {};
	virtual void OnTriggerExit(const Collider& Collided) {};

	virtual void Awake() {};
	virtual void Start() {};
	virtual void FixedUpdate() {};
	virtual void Update() {};
};

class Renderer : public GameComponent
{
public:

	// Variables

public:

	// Functions

	inline Renderer();

	virtual void Update() = 0;

	virtual void Draw() = 0;

	virtual uint32 GetLayer()
	{
		return EntityAttachedTo->Layer;
	}
};

class Sprite : public Entity
{
public:

	// Variables

	KRectangle TextureRect;
	SDL_Texture* SpriteSheet;

	BoundingBox Bounds;

public:

	// Functions

	inline Sprite()
	{
		TextureRect = KRectangle(Vector2(0, 0), Vector2(32, 32));
		Bounds = BoundingBox(Vector2(16, 16), Vector2(32, 32));
	}

	inline Sprite(const string &FileName,
		struct KRectangle TextureRectangle)
	{
		SetupSprite(FileName, TextureRectangle);
	}

	inline void SetupSprite(const string &FileName, struct KRectangle TextureRectangle);
};

class Collider : public GameComponent
{
public:

	// Variables

	UniqueID* CellIndex;

	// The density of the collider used to calculate its mass (when auto mass is enabled).
	real32 Density;

	// The number of separate shaped regions in the collider.
	int32 ShapeCount;

	// Enabled Colliders will collide with other colliders, disabled Colliders won't.
	bool32 Enabled;

	// 	The local offset of the collider geometry.
	Vector2 Offset;

	// Is this collider configured as a trigger ?
	bool32 IsTrigger;

	// 	The world space bounding area of the collider.
	BoundingBox Bounds;

public:

	// Functions

	inline Collider();

	inline virtual void OnCollisionStart(const Collision& CollideInfo)
	{
		for (const auto& Iterator : EntityAttachedTo->Components)
		{
			GameBehaviour* Collision = dynamic_cast<GameBehaviour*>(Iterator);

			if (Collision)
			{
				Collision->OnCollisionStart(CollideInfo);
			}
		}
	}

	inline virtual void OnCollisionStay(const Collision& CollideInfo)
	{
		for (const auto& Iterator : EntityAttachedTo->Components)
		{
			GameBehaviour* Collision = dynamic_cast<GameBehaviour*>(Iterator);

			if (Collision)
			{
				Collision->OnCollisionStay(CollideInfo);
			}
		}
	}

	inline virtual void OnCollisionEnd(const Collision& CollideInfo)
	{
		for (const auto& Iterator : EntityAttachedTo->Components)
		{
			GameBehaviour* Collision = dynamic_cast<GameBehaviour*>(Iterator);

			if (Collision)
			{
				Collision->OnCollisionEnd(CollideInfo);
			}
		}
	}

	// Sent when another object enters a trigger collider attached to this object.
	inline virtual void OnTriggerEnter(const Collider& Collided)
	{
	}

	// Sent each frame where another object is within a trigger collider attached to this object.
	inline virtual void OnTriggerStay(const Collider& Collided)
	{
	}

	// Sent when another object leaves a trigger collider attached to this object.
	inline virtual void OnTriggerExit(const Collider& Collided)
	{
	}

	// Whether the collider is touching this collider or not.
	inline virtual bool32 IsTouching(Collider& Collided)
	{
		return GetBounds().Intersects(Collided.GetBounds());
	}

	// Whether the collider is touching this collider or not.
	inline virtual bool32 IsTouching(Collider* Collided)
	{
		return GetBounds().Intersects(Collided->GetBounds());
	}

	// Does point overlap the collider?
	inline virtual bool32 OverlapPoint(Vector2 Point)
	{
		return GetBounds().Contains(Point);
	}

	// Whether this collider is touching any collider on the specified layerMask or not.
	inline virtual bool32 IsTouchingLayers(int32 LayerMask = 0) // All layers
	{
		return TRUE;
	}

	inline BoundingBox GetBounds();

	bool operator == (const Collider& Other)
	{
		return InstanceID == Other.InstanceID;
	}
};

class BoxCollider : public Collider
{
public:

	// Variables

	Vector2 Size;

public:

	// Functions

	inline BoxCollider()
	{
	}
};

class EdgeCollider : public Collider
{
public:

	// Variables

	// Gets the number of edges.
	int32 EdgeCount;

	// Gets the number of points.
	int32 PointCount;

	// Get or set the points defining multiple continuous edges.
	std::vector<Vector2> Points;	

public:

	// Functions

	void Reset();

	// Whether the collider is touching this collider or not.
	inline virtual bool32 IsTouching(Collider& Collided) override
	{
		return GetBounds().Intersects(Collided.GetBounds());
	}

	// Whether the collider is touching this collider or not.
	inline virtual bool32 IsTouching(Collider* Collided)
	{
		return GetBounds().Intersects(Collided->GetBounds());
	}

	inline bool32 IsTouching(Vector2 Start, Vector2 DeltaEnd, int32 PaddingX = 0, int32 PaddingY = 0)
	{
		real32 ScaleX = 1.0 / DeltaEnd.X;
		real32 ScaleY = 1.0 / DeltaEnd.Y;
		int32 SignX = SignOf(ScaleX);
		int32 SignY = SignOf(ScaleY);

		real32 NearTimeX = (GetBounds().Center.X - SignX * (GetBounds().Extents.X + PaddingX) - Start.X) * ScaleX;
		real32 NearTimeY = (GetBounds().Center.Y - SignY * (GetBounds().Extents.Y + PaddingY) - Start.Y) * ScaleY;
		real32 FarTimeX = (GetBounds().Center.X + SignX * (GetBounds().Extents.X + PaddingX) - Start.X) * ScaleX;
		real32 FarTimeY = (GetBounds().Center.Y + SignY * (GetBounds().Extents.Y + PaddingY) - Start.Y) * ScaleY;

		if (NearTimeX > FarTimeY || NearTimeY > FarTimeX)
		{
				return FALSE;
		}

		real32 NearTime;
				if (NearTimeX > NearTimeY)
				{
					NearTime = NearTimeX;
				}
				else
				{
					NearTime = NearTimeY;
				}
				
				real32 FarTime;
				if(FarTimeX < FarTimeY)
				{
					FarTime = FarTimeX;
				}
				else 
				{
					FarTime = FarTimeY;
				}

				if (NearTime >= 1 || FarTime <= 0)
				{
					return FALSE;
				}


				Collision Hit;
				int32 DidHit = Clamp01(NearTime);
				if (NearTimeX > NearTimeY)
				{
					Hit.Normal.X = -SignX;
					Hit.Normal.Y = 0;
				}
				else
				{
					Hit.Normal.X = 0;
						Hit.Normal.Y = -SignY;
						Hit.RelativeVelocity.X = DidHit * DeltaEnd.X;
						Hit.RelativeVelocity.Y = DidHit * DeltaEnd.Y;

						Vector2 Contact;
						Contact.X = GetBounds().Center.X + hit.delta.x;
						Contact.Y = pos.y + hit.delta.y;
				}
						
				return Hit;
	}
};

class SpriteRenderer : public Renderer
{
public:

	// Variables

	Sprite SpriteToRender;

public:

	// Functions

	inline SpriteRenderer()
	{
	}

	inline virtual void Update() override
	{
	}

	inline virtual void Draw() override
	{
		KRectangle DestinationRectangle = KRectangle(EntityAttachedTo->EntTransform.Position,
			SpriteToRender.Bounds.GetSize() * EntityAttachedTo->EntTransform.Scale);
		// RenderGraphics.BlitSurface(SpriteSheet, &SourceRect, &DestinationRectangle);

		BlitSprite(SpriteToRender.TextureRect.ToSDLRect(), DestinationRectangle.ToSDLRect());
	}

	inline void BlitSprite(SDL_Rect Source, SDL_Rect Destination);
};

// TODO(Julian): Maybe do a override call instead of inheritence
class SpriteAnimator : public SpriteRenderer
{
public:

	// Variables

	// SpriteRenderer* Renderer;

	std::map<string, std::vector<SDL_Rect> > Animations;
	std::map<string, Vector2> Offsets;

	uint32 FrameIndex;
	real64 TimeElapsed;
	bool32 IsVisible;

	real64 TimeToUpdate;
	bool32 CurrentAnimPlayOnce;
	string CurrentAnim;

public:

	// Functions

	inline SpriteAnimator()
	{
		TimeToUpdate = 100.0;
		FrameIndex = 0;
		TimeElapsed = 0.0;
		IsVisible = 1;
		CurrentAnimPlayOnce = 0;
		CurrentAnim = "";

		// Renderer = new SpriteRenderer();

		// GameEventSystem::EventSystem->AddUpdateHandler(this);
	}

	inline void PlayAnimation(string Animation, bool32 PlayOnce = 0)
	{
		CurrentAnimPlayOnce = PlayOnce;

		if (CurrentAnim != Animation)
		{
			CurrentAnim = Animation;
			FrameIndex = 0;
		}
	}

	inline virtual void Draw() override
	{
		if (IsVisible == 1)
		{
			// TODO(Julian): Fix this
			KRectangle DestinationRectangle =
			{
				EntityAttachedTo->EntTransform.Position + Offsets[CurrentAnim],
				SpriteToRender.TextureRect.GetSize()
			};

			KRectangle SourceRectangle = { Animations[CurrentAnim][FrameIndex] };

			SpriteToRender.TextureRect = SourceRectangle;

			BlitSprite(SourceRectangle.ToSDLRect(), DestinationRectangle.ToSDLRect());
		}
	}

	inline void AddAnimation(uint32 Frames, uint32 X, uint32 Y, string AnimationName, uint32 Width, uint32 Height, Vector2 Offset)
	{
		std::vector<SDL_Rect> Rectangles;

		for (uint32 Index = 0; Index < Frames; ++Index)
		{
			SDL_Rect Rect = { (int32)(Index + X) * (int32)Width, (int32)Y, (int32)Width, (int32)Height };
			Rectangles.push_back(Rect);
		}

		Animations.insert(std::pair<string, std::vector<SDL_Rect> >(AnimationName, Rectangles));
		Offsets.insert(std::pair<string, Vector2>(AnimationName, Offset));
	}

	inline virtual void AnimationDone(string CurrentAnimation)
	{
	}

	inline void ResetAnimations()
	{
		Animations.clear();
		Offsets.clear();
	}

	inline void StopAnimation()
	{
		FrameIndex = 0;
		AnimationDone(CurrentAnim);
	}

	inline void SetVisible(bool32 Visible)
	{
		IsVisible = Visible;
	}

	inline virtual void Update() override
	{
		TimeElapsed += Time::DeltaTime;

		if (TimeElapsed > TimeToUpdate)
		{
			TimeElapsed -= TimeToUpdate;

			if (FrameIndex < Animations[CurrentAnim].size() - 1)
			{
				FrameIndex++;
			}
			else
			{
				if (CurrentAnimPlayOnce == 1)
				{
					SetVisible(0);
				}

				StopAnimation();
			}
		}
	}
};

class PhysicsComponent : public GameBehaviour
{
public:

	// Variables

	// Collider2D* Collider;

public:

	// Functions

	inline PhysicsComponent();
};

class RigidBody2D : public PhysicsComponent
{
public:

	// Variables

	real32 GravityRate = 5.0f;
	real32 GravityMax = 10.0f;
	real32 Friction = 0.5f;
	real32 Mass = 1.0f;

	Vector2 Velocity = Vector2(0, 0);
	Vector2 MaxVelocity = Vector2(10.0f, 100.0f);
	Vector2 Acceleration = Vector2(0, 0);

	Collider* BodyCollider;

	Collider* Ground;
	bool32 IsGrounded = FALSE;
	bool32 IsLeftWall = FALSE;
	bool32 IsRightWall = FALSE;

public:

	// Functions

	inline RigidBody2D()
	{
	}

	inline virtual void OnCollisionStart(const Collision& CollideInfo) override
	{
		Transform* EntTransform = &EntityAttachedTo->EntTransform;

		if (CollideInfo.Normal.Y > 0.0f)
		{
			IsGrounded = TRUE;
			Ground = CollideInfo.Collider;
		}
		else if (CollideInfo.Normal.Y < 0.0f)
		{
			Velocity.Y = 0.0f;
		}
		else
		{

		}

		if (CollideInfo.Normal.X > 0.0f)
		{
			if (Velocity.X > 0.0f)
			{
				Velocity.X = 0.0f;
				EntTransform->Position.X -= 1.0f;
			}
		}
		else if (CollideInfo.Normal.X < 0.0f)
		{
			if (Velocity.X < 0.0f)
			{
				Velocity.X = 0.0f;
				EntTransform->Position.X += 1.0f;
			}
		}
	}

	inline virtual void OnCollisionStay(const Collision& CollideInfo) override
	{
		Transform* EntTransform = &EntityAttachedTo->EntTransform;

		if (CollideInfo.Normal.Y > 0.0f)
		{
			IsGrounded = TRUE;
			Ground = CollideInfo.Collider;
		}
		else if (CollideInfo.Normal.Y < 0.0f)
		{
			Velocity.Y = 0.0f;
		}
		else
		{

		}

		if (CollideInfo.Normal.X > 0.0f)
		{
			if (Velocity.X > 0.0f)
			{
				Velocity.X = 0.0f;
				EntTransform->Position.X -= 1.0f;
			}
		}
		else if (CollideInfo.Normal.X < 0.0f)
		{
			if (Velocity.X < 0.0f)
			{
				Velocity.X = 0.0f;
				EntTransform->Position.X += 1.0f;
			}
		}
	}

	inline virtual void OnCollisionEnd(const Collision& CollideInfo) override
	{
		if (CollideInfo.Collider == Ground)
		{
			Ground = nullptr;
			IsGrounded = FALSE;
		}
	}

	inline void AddFriction()
	{
		if (!IsGrounded)
		{
			if (Velocity.Y > GravityMax)
			{
				Velocity.Y = GravityMax;
			}
			else
			{
				Velocity.Y += GravityRate;
			}
		}
		else
		{
			if (Velocity.Y > 0.0f)
			{
				Velocity.Y = 0.0f;
			}
		}

		if (AbsoluteValue(Velocity.X) < 0.1f)
		{
			Velocity.X = 0.0f;
		}
		else
		{
			if (Velocity.X > 0.0f)
			{
				Velocity.X -= Friction;
			}
			else if (Velocity.X < -0.0f)
			{
				Velocity.X += Friction;
			}
		}

		Velocity.X = SignOf(Velocity.X) * Clamp(0.0f, AbsoluteValue(Velocity.X), MaxVelocity.X);
		Velocity.Y = SignOf(Velocity.Y) * Clamp(0.0f, AbsoluteValue(Velocity.Y), MaxVelocity.Y);
	}

	inline void Update() override
	{
		
	}

	inline void FixedUpdate() override
	{
		AddFriction();

		EntityAttachedTo->EntTransform.Position += Velocity * (real32)Time::FixedUpdate;

		// Position.X += Velocity.X * (real32)Time::DeltaTime;

		// Position.Y += Velocity.Y * (real32)Time::DeltaTime;

		/*

		if (Velocity.X != 0.0f && Velocity.Y != 0.0f)
		{
		AddFriction();
		}

		Velocity += Acceleration * (real32)Time::DeltaTime;

		int32 Factorial = Velocity.X > 0 ? 1 : -1;
		Velocity.X = Min(AbsoluteValue(Velocity.X), MaxVelocity.X) * Factorial;

		Position += Velocity;
		// Velocity.X = 0;

		// Position += (real32)Time::DeltaTime * (Velocity * Acceleration * 0.5f);
		// Velocity += Acceleration - (Friction * Velocity);

		*/

		// ObjectSprite->Update(Position, ElapsedTime);
	}
};

enum class DIRECTION
{
	UP,
	DOWN,
	LEFT,
	RIGHT
};

class Player : public GameBehaviour
{
public:

	// Variables

	SpriteAnimator* Animator;
	RigidBody2D* RigidBody;
	Collider* PlayerCollider;

	DIRECTION CurrentDirection;

	real32 Speed = 5.0f;
	real32 JumpAmount = 75.0f;

public:

	// Functions

public:

	inline Player()
	{
	}

	inline Player(GameEntity* GameObject, Vector2 ObjectPosition)
	{
		// GameObject->Location->Position = ObjectPosition;
		CurrentDirection = DIRECTION::RIGHT;

		// GameEntity* PlayerObject = new GameEntity("Player");
		EntityAttachedTo = GameObject;

		// GameObject = new GameEntity();
		// GameObject.EntTransform = GameObject->AddComponent<Transform>();
		// GameObject->EntTransform = new Transform();
		EntityAttachedTo->EntTransform.Position = ObjectPosition;
		Animator = EntityAttachedTo->AddComponent<SpriteAnimator>();
		// Animator->GameEnt = GameObject;
		// Animator->EntityAttachedTo = &GameObject;
		Animator->SpriteToRender.SetupSprite("../Data/Images/MyChar.bmp",
			KRectangle(0, 0, 32, 32));

		// "../Data/Images/MyChar.bmp", SDL_Rect{ 0, 0, 32, 32 }, ObjectPosition, 300
		// GameObject->Components.push_back(Animator);

		Animator->AddAnimation(1, 0, 0, "IdleLeft", 32, 32, Vector2(0, 0));
		Animator->AddAnimation(1, 0, 32, "IdleRight", 32, 32, Vector2(0, 0));

		Animator->AddAnimation(3, 0, 0, "RunLeft", 32, 32, Vector2(0, 0));
		Animator->AddAnimation(3, 0, 32, "RunRight", 32, 32, Vector2(0, 0));

		Animator->PlayAnimation("RunRight");

		Name = "Player";

		EntityAttachedTo->Name = Name;
		EntityAttachedTo->Layer = 1;
		Animator->Layer = 1;

		RigidBody = EntityAttachedTo->AddComponent<RigidBody2D>();
		PlayerCollider = EntityAttachedTo->AddComponent<BoxCollider>();
		RigidBody->BodyCollider = PlayerCollider;
		PlayerCollider->Bounds = BoundingBox(Vector2(16, 16), Vector2(24, 32));
	}

	inline void Move(DIRECTION FacingDirection)
	{
		CurrentDirection = FacingDirection;

		switch (FacingDirection)
		{
		case DIRECTION::LEFT:
			// GameObject.EntTransform.Position.X = -Speed;
			RigidBody->Velocity.X = -Speed;
			Animator->PlayAnimation("RunLeft");
			break;
		case DIRECTION::RIGHT:
			// Velocity.X = Speed;
			RigidBody->Velocity.X = Speed;
			Animator->PlayAnimation("RunRight");
			break;

		default:
			break;
		}
	}

	inline void StopMove()
	{
		// AnimatedSprite* AnimSprite = (AnimatedSprite *)ObjectSprite;
		// RigidBody->Velocity.X = 0.0f;
		switch (CurrentDirection)
		{
		case DIRECTION::LEFT:
			Animator->PlayAnimation("IdleLeft");
			break;
		case DIRECTION::RIGHT:
			Animator->PlayAnimation("IdleRight");
			break;

		default:
			break;
		}
	}

	inline void Jump()
	{
		RigidBody->Velocity.Y -= JumpAmount;
		RigidBody->IsGrounded = FALSE;
	}

	virtual void OnCollisionStart(const Collision& Collide) override
	{
	}

	inline virtual void Awake() override {};
	inline virtual void Start() override {};
	inline virtual void FixedUpdate() override {};
	inline virtual void Update() override {};
};

class Tile : public GameBehaviour
{
public:

	SpriteRenderer* EntRenderer;
	SDL_Texture* TileSet;

	inline Tile()
	{
	}

	inline Tile(SDL_Texture* TileSetTexture, Vector2 TilePosition, Vector2 TileSetPosition, Vector2 TileSetSize)
	{
		Name = "Tile";
		TileSet = TileSetTexture;

		EntityAttachedTo = new GameEntity("Tile");
		EntityAttachedTo->EntTransform.Position = TilePosition;
		EntityAttachedTo->EntTransform.Scale = Vector2(1.0f, 1.0f);

		EntRenderer = EntityAttachedTo->AddComponent<SpriteRenderer>();
		EntRenderer->SpriteToRender.SpriteSheet = TileSetTexture;
		EntRenderer->SpriteToRender.TextureRect = KRectangle(TileSetPosition, TileSetSize);
	}

	inline void Update() override
	{
	}
};

class PhysicsTile : public Tile
{
public:

	// Variables

	BoxCollider* Collider;

public:

	inline PhysicsTile()
	{
	}

	inline PhysicsTile(SDL_Texture* TileSetTexture, BoundingBox PhysicsBox, Vector2 TileSetPosition, Vector2 TileSetTextureMin, Vector2 TileSetTextureMax) :
		Tile(TileSetTexture, TileSetPosition, TileSetTextureMin, TileSetTextureMax)
	{
		Name = "PhysicalTile";
		EntityAttachedTo->Name = "PhysicsTile";
		Collider = EntityAttachedTo->AddComponent<BoxCollider>();
		//Collider->Bounds.X = (uint32)TilePosition.X;
		//Collider->Bounds.Y = (uint32)TilePosition.Y;
		Collider->Bounds = PhysicsBox;
		EntRenderer->SpriteToRender.Bounds = PhysicsBox;
		// Collider->Bounds.X = 0;
		// Collider->Bounds.Y = 0;
		// Collider->Bounds.Width = (uint32)TileSize.X;
		// Collider->Bounds.Height = (uint32)TileSize.Y;
		// Collider->Offset = { 0, 0 };
	}
};

struct Tileset
{
	SDL_Texture* Texture;
	int32 FirstGID;

	Tileset()
	{
		FirstGID = -1;
	}

	Tileset(SDL_Texture* TileSetTexture, int32 TilesetFirstGID)
	{
		Texture = TileSetTexture;
		FirstGID = TilesetFirstGID;
	}
};

class Level : public GameBehaviour
{
public:

	// Variables

	string MapName;
	Vector2 SpawnPoint;

	Vector2 LevelSize;
	Vector2 TileSize;

	SDL_Texture* BackgroundTexture;

	std::vector<Tile*> TileList;
	std::vector<Tileset> TileSets;

public:

	// Functions

	inline Level()
	{
	}

	inline Level(string LevelMapName, Vector2 LevelSpawnPoint)
	{
		MapName = LevelMapName;
		SpawnPoint = LevelSpawnPoint;
		LevelSize = Vector2(0, 0);

		LoadMap(MapName);
	}

	inline Level(GameEntity* GameObject, string FileName)
	{
		Name = "Level";
		EntityAttachedTo = GameObject;

		LoadMapFile(FileName);
	}

	inline void LoadMapFile(string LevelMapName);

	inline void LoadMap(string LevelMapName);

	inline virtual void Update() override
	{
	}

	inline void Draw()
	{
	}
};

#define KANTI2D_GAMEOBJECT

#endif
