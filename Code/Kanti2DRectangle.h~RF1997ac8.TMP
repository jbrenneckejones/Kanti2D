#ifndef KANTI2D_RECTANGLE

enum class SIDE
{
	TOP,
	BOTTOM,
	LEFT,
	RIGHT,
	NONE
};

k_internal inline SIDE GetOppositeSide(SIDE CurrentSide)
{
	switch (CurrentSide)
	{
	case SIDE::TOP:
		return SIDE::BOTTOM;
	case SIDE::BOTTOM:
		return SIDE::TOP;
	case SIDE::LEFT:
		return SIDE::RIGHT;
	case SIDE::RIGHT:
		return SIDE::LEFT;
	case SIDE::NONE:
		return SIDE::NONE;
	default:
		return SIDE::NONE;
	}
}

struct KRectangle
{
public:

	union
	{
		struct
		{
			real32 X, Y, Width, Height;
		};

		struct
		{
			Vector2 Position;
			Vector2 Size;
		};
	};

public:

	inline KRectangle()
	{
	}

	inline KRectangle(real32 RectX, real32 RectY, real32 RectWidth, real32 RectHeight)
	{
		X = (RectX);
		Y = (RectY);
		Width = (RectWidth);
		Height = (RectHeight);
	}

	inline KRectangle(uint32 RectX, uint32 RectY, uint32 RectWidth, uint32 RectHeight)
	{
		X = (real32)RectX;
		Y = (real32)RectY;
		Width = (real32)RectWidth;
		Height = (real32)RectHeight;
	}

	inline KRectangle(int32 RectX, int32 RectY, int32 RectWidth, int32 RectHeight)
	{
		X = (real32)RectX;
		Y = (real32)RectY;
		Width = (real32)RectWidth;
		Height = (real32)RectHeight;
	}

	inline KRectangle(Vector2 RectPosition, Vector2 RectSize)
	{
		Position = RectPosition;
		Size = RectSize;
	}

	inline KRectangle(SDL_Rect SDLRectangle)
	{
		SetRectangle(SDLRectangle);
	}

	inline bool32 operator == (const KRectangle& Comparer)
	{
		bool32 Result = Position == Comparer.Position && Size == Comparer.Size;

		return (Result);
	}

	bool32 operator <(const KRectangle& Comparer)
	{
		return Position < Comparer.Position && Position < Comparer.Size;
	}

	inline void SetRectangle(SDL_Rect Rectangle)
	{
		X = (real32)Rectangle.x;
		Y = (real32)Rectangle.y;
		Width = (real32)Rectangle.w;
		Height = (real32)Rectangle.h;
	}

	bool32 IsValidRect()
	{
		bool32 Result = X >= 0 && Y >= 0 && Width >= 0 && Height >= 0;

		return (Result);
	}

	SDL_Rect ToSDLRect()
	{
		SDL_Rect Result = { (int32)X, (int32)Y, (int32)Width, (int32)Height };

		return (Result);
	}

	inline real32 GetLeft()
	{
		return X;
	}

	inline real32 GetRight()
	{
		return X + Width;
	}

	inline real32 GetTop()
	{
		return Y;
	}

	inline real32 GetBottom()
	{
		return Y + Height;
	}

	inline Vector2 GetSize()
	{
		return (Size);
	}

	inline Vector2 GetPosition()
	{
		return (Position);
	}
};

struct Ray
{
	// The starting point of the ray in world space.
	Vector2 Origin;

	// The direction of the ray in world space.
	Vector2 Direction;

	Vector2 GetPoint(real32 Distance)
	{

	}
};

struct BoundingBox
{
	// Variables

	// The center of the bounding box.
	Vector2 Center;

	// The extents of the box.This is always half of the size.
	// Note: If Bounds.extents has a negative value for any axis, Bounds.Contains always returns False.
	Vector2 Extents;

	// The total size of the box.This is always twice as large as the extents.
	// size.x is the width, size.y is the height and size.z is the depth of the box.
	Vector2 GetSize()
	{
		return Extents * 2.0f;
	}

	// Left hand top corner position
	// The minimal point of the box.
	// This is always equal to center - extents.
	Vector2 GetMin()
	{
		return Center - Extents;
	}

	// The maximal point of the box.
	// This is always equal to center + extents.
	Vector2 GetMax()
	{
		return Center + Extents;
	}

	// Functions

	inline BoundingBox()
	{
		Center = Vector2(16, 16);

		BoundingBox(Center, Vector2(32, 32));
	}

	/*
		Creates a new Bounds.

		Create a new Bounds with the given left hand position and total size. 
		Bound extents will be half the given size.
	*/
	inline BoundingBox(Vector2 BoxCenter, Vector2 BoxSize)
	{
		Center = BoxCenter;
		Extents = BoxSize * 0.5f;
	}

	// Converts SDL Rect to our rect
	inline BoundingBox(SDL_Rect SDLRectangle)
	{
		BoundingBox({ SDLRectangle.x, SDLRectangle.y }, { SDLRectangle.w, SDLRectangle.h });
	}

	/*
		Returns : Vector2 The point on the bounding box or inside the bounding box.

		Description : The closest point on the bounding box. 
		If the point is inside the bounding box, unmodified point position will be returned.
	*/
	inline Vector2 ClosestPoint(Vector2 Point)
	{
		if (Contains(Point))
		{
			return Point;
		}
		else
		{
			real32 DeltaX = Point.X - Center.X;
			real32 PixelX = Extents.X - AbsoluteValue(DeltaX);
			if (PixelX <= 0)
			{
				return Vector2::Zero;
			}

			real32 DeltaY = Point.Y - Center.Y;
			real32 PixelY = Extents.Y - AbsoluteValue(DeltaY);
			if (PixelY <= 0)
			{
				return Vector2::Zero;
			}

			if (PixelX < PixelY)
			{
				real32 SurfaceX = SignOf(DeltaX);
				// hit.delta.x = px * sx
				// hit.normal.x = sx
				Point.X = Center.X + (Extents.X * SurfaceX);
				// Point.Y = Point.Y;
			}
			else
			{
				real32 SurfaceY = SignOf(DeltaY);
				// hit.delta.y = py * sy
				// hit.normal.y = sy
				// Point.X = Point.X;
				Point.Y = Point.Y + (Extents.Y * SurfaceY);
			}

			return Point;
		}
	}

	/*
		Description : Is point contained in the bounding box? 
		If the point passed into Contains is inside the bounding box a value of True is returned.

		Note: If Bounds.extents contains a negative value in any coordinate then Bounds.Contains will always return False.
	*/
	inline bool32 Contains(Vector2 Point)
	{
		if (
			Point.X > GetMin().X && Point.X < GetMax().X &&
			Point.Y > GetMin().Y && Point.Y < GetMax().Y
		   )
		{
			return TRUE;
		}

		return FALSE;
	}

	/*
		Description : Grows the Bounds to include the point.
	*/
	inline void Encapsulate(Vector2 Point)
	{
		SetMinMax(Vector2::Min(GetMin(), Point), Vector2::Max(GetMax(), Point));
	}

	/*
	Description : Grows the Bounds to include the point.
	*/
	inline void Encapsulate(BoundingBox Box)
	{
		Encapsulate(Box.Center - Box.Extents);
		Encapsulate(Box.Center + Box.Extents);
	}

	/*
		Description : Expand the bounds by increasing its size by amount along each side.
	*/
	inline void Expand(real32 ExpansionAmount)
	{
		ExpansionAmount *= 0.5f;
		Extents += Vector2(ExpansionAmount, ExpansionAmount);
	}

	inline void Expand(Vector2 ExpansionAmount)
	{
		Extents += ExpansionAmount * 0.5f;
	}

	/*
		Description : Does ray intersect this bounding box?
	*/
	inline bool32 IntersectsRay(Ray RayLine)
	{

	}

	/*
		Description : Does another bounding box intersect with this bounding box?
	*/
	inline bool32 Intersects(BoundingBox Box)
	{
		Vector2 Delta1, Delta2;
		Delta1 = Box.GetMin() - GetMax();
		Delta2 = GetMin() - Box.GetMax();

		if (Delta1.X > 0.0f || Delta1.Y > 0.0f)
			return false;

		if (Delta2.X > 0.0f || Delta2.Y > 0.0f)
			return false;

		return true;
	}

	/*
		Description : Sets the bounds to the min and max value of the box.
		Using this function is faster than assigning min and max separately.
	*/
	inline void SetMinMax(Vector2 BoxMin, Vector2 BoxMax)
	{
		Extents = (BoxMax - BoxMin) * 0.5f;
		Center = BoxMin + Extents;
	}

	inline void SetPositionSize(Vector2 BoxPosition, Vector2 BoxSize)
	{
		Center = BoxPosition + (BoxSize * 0.5f);
		Extents = BoxSize * 0.5f;
	}

	inline k_internal BoundingBox GetPositionSize(Vector2 BoxPosition, Vector2 BoxSize)
	{
		BoundingBox Result;
		Result.SetPositionSize(BoxPosition, BoxSize);

		return (Result);
	}

	/*
		Description : The smallest squared distance between the point and this bounding box.
	*/
	inline real32 SquareDistance(Vector2 Point)
	{
		real32 MinDistance = GetMin().Distance(Point);
		real32 MaxDistance = GetMax().Distance(Point);

		real32 Result = MinDistance < MaxDistance ? MinDistance : MaxDistance;

		return (Result);
	}
};

#define KANTI2D_RECTANGLE
#endif
